# PATTERNS

Единый контракт разработки для проекта `crawler-app`.

## 1. Reuse First

- Сначала ищем существующий паттерн/компонент/хелпер.
- Если паттерн есть, переиспользуем; не дублируем логику.
- Если паттерна нет, выносим reusable-решение и применяем минимум в 2 местах.

## 1.1 Audit-правило: No-Regression Refactor

- Любой аудит/реюз/чистка кода выполняются без изменения текущего поведения.
- Сначала фиксируем “как сейчас работает”, потом выносим в реюз, не меняя UX/логику.
- Если требуется изменение поведения, это отдельная согласованная задача.
- Для критичных сценариев (события/monitoring/drawer) фиксируем анти-регресс правила в `PATTERNS.md` и/или `REUSE_INDEX.md`.

### Audit Regression Checklist (обязательно перед рефактором)

1. Зафиксировать текущий UX:
`скрин/описание` ключевых состояний + “что считается корректным”.
2. Выделить критичные сценарии и анти-регресс правила.
3. Вынести логику в reusable-модуль без изменения поведения.
4. Проверить UI вручную:
`EventsPage`, `SidebarRight`, `ActivityLogPage`, `MonitoringPage`, `UsersPage`.
5. Проверить экспорт/действия:
файлы скачиваются, кнопки/лейблы не изменены.
6. Зафиксировать результат в `REUSE_INDEX.md`:
что вынесли, где применяется, какие правила нельзя ломать.

## 2. Backend-driven правила

- UI не хранит бизнес-правила безопасности.
- Applicability, critical, reason-policy, presets, labels приходят из backend-каталогов.
- Добавление нового admin-действия: registry/catalog + handler на backend.
- Загрузка backend-каталогов (`actions/trust/audit actions`) выполняется через единый frontend TTL-кэш с dedupe in-flight запросов, а не через разрозненные локальные `apiGet` в каждой странице.
- Загрузка user-context в drawer (`email/id -> details + available-actions`) выполняется через единый reusable loader (`loadUserContextByEmail/loadUserContextById`), чтобы не дублировать цепочку запросов в страницах.

## 3. RBAC и роли

- Любая функция проверяется по ролям и разрешениям.
- Матрица прав единая и используется backend+frontend.
- UI показывает действия только для разрешенных ролей.
- Хаб `Настройки` доступен только ролям с `users.manage` (admin/root-admin); для остальных скрывается и закрыт по роуту.

## 4. Audit + Events + Monitoring (тройной след)

Любая важная функция должна быть интегрирована сразу в три канала:

- Audit-log: кто, что, когда, над кем, reason.
- Event Center: событие с deep-link.
- Monitoring: метрики успех/ошибка/объем.
- Для тяжелых monitoring-агрегатов (`/metrics`, `/admin/monitoring/history`, `/admin/monitoring/history/focus`)
  используем короткий backend TTL-кэш с явными правилами инвалидции:
  - пассивная инвалидция по TTL;
  - активная инвалидция при изменении monitoring-настроек;
  - опциональный `force_refresh` для явного bypass в диагностических сценариях.

## 5. Deep-link + highlight

- Событие должно вести в релевантный экран.
- Экран назначения обязан уметь подсветить релевантную запись/карточку.
- Переходы единообразны в Sidebar Event Center и в полной странице Центра событий.

## 6. Unread/read паттерн

- Единое поведение: `клик по карточке -> mark read -> deep-link`.
- Read/hidden state хранится в БД per-user (для multi-admin).
- Статус `обработано` для событий хранится в БД per-user (`event_user_state.is_handled/handled_at`), а не только в локальном UI.
- Для событийных лент используем отдельный фильтр `Только необработанные` (работает поверх прочих фильтров и не ломает deep-link).
- Один админ не меняет read-state другого админа.
- Unread-счетчики Event Center в frontend читаются через shared store/кэш (не через независимые запросы из разных экранов в одной вкладке).
- Транспорт Event Center централизован: `SSE-first` (push), при недоступности push автоматически включается fallback polling.
  Управление транспортом выполняется через единый singleton manager (один активный транспорт на вкладку/приложение), а не через локальные `setInterval` в нескольких экранах.

## 7. Паттерн списков и автоподгрузки

- Стандарт: `base 20 + scroll incremental load`.
- Применяется для лент/таблиц (Users, Events, Activity и т.д.).
- Локальные селекты `20/50/100/Все` не используем там, где утвержден этот паттерн.
- Для экранов внутри workspace автодогрузка вешается на скролл-контейнер workspace, а не на `window`, чтобы не ломаться при внутреннем скролле layout.
- Для списков с автодогрузкой используем единый hook `useWorkspaceInfiniteScroll` (workspace-container first, fallback window, short-content prefetch),
  а не локальные `addEventListener("scroll")` в каждой странице.
- Для selectable-списков в админке (`Users`, `RootAdmins`) используем общий row-компонент `SelectableListRow`
  (чекбокс + контент + `Открыть` + hover/highlight, без постоянной светлой рамки), чтобы плотность/анимации строк не расходились между страницами.
- Любая новая лента/таблица с incremental-load обязана сразу подключать `useWorkspaceInfiniteScroll` и `useIncrementalPager` (если есть server-pagination).
- Для непагинированных сервером списков (`Users`, `RootAdmins`) используем тот же `useWorkspaceInfiniteScroll` для инкрементального рендера (windowing по количеству карточек),
  чтобы не рендерить весь DOM сразу на больших наборах.
- Для page-level лент (`Events`, `Activity`) используем единый pagination-hook (`load/reset/append + next-page guard + anti-race request-seq`), чтобы не дублировать логику загрузчиков.
- Для page-level загрузчиков используем доменные shared-hooks поверх этого pagination-hook:
  `useUsersList`, `useEventFeed`, `useActivityFeed` (guard/cancel/retry единообразны, без локального дублирования fetch-pipeline на страницах).
- Для async загрузки drawer-контекста используем общий guarded-lifecycle hook (`useGuardedAsyncState`)
  вместо локальных `requestSeq/active` блоков в каждой странице.
- Для page-level загрузчиков обязателен `AbortController`: при смене фильтров/контекста отменяем устаревшие in-flight запросы (не только игнорируем ответ), чтобы снижать лишнюю серверную нагрузку.
- Исключение для правого `SidebarRight`: в компактной панели держим фиксированное окно `top-20` для `Уведомлений` и `Ленты действий` (без локальной бесконечной догрузки); полный объем доступен на странице `Центр событий`.

## 8. Паттерн действий карточек

- Общие действия: открыть источник, read/unread, скрыть/показать.
- Контекстные действия идут через общий popover/menu компонент.
- Не делаем отдельные уникальные кнопочные схемы для одинаковых сценариев.
- Для `ActivityLogPage` и `EventsPage`: primary-клик по карточке открывает контекст в `SlidePanel`; переход на источник выполняется явной кнопкой `Открыть источник`.
- Для toast-уведомлений при свернутом правом сайдбаре: используем контекст события (`title/body/severity`), primary-клик/кнопка `Открыть` выполняют релевантное действие события (не общий переход на страницу).
- Для toast-уведомлений: `pause on hover` обязателен для длинного текста; таймер и progress-бар замораживаются на время ховера.
- Для toast-уведомлений на desktop добавляем вторичное действие `Открыть контекст` (drawer), primary-действие остается `Открыть источник`.
- Для событий `monitoring.anomaly` в `SlidePanel` добавляем контекст наблюдаемости: мини-график по `focus_metric` и список связанных ошибок (по `focus_path`, если задан).
- Для `monitoring.anomaly` в контексте события обязательно показываем блок `Рекомендация`: `что делать`, `почему`, список следующих шагов.
- В графике мониторинга в drawer показываем маркер момента события (если `event_ts/detected_at_utc` есть в `meta`) и явное пояснение `live-динамика vs момент события`.
- Для monitoring-контекста график загружается только через общий loader (`loadMonitoringContext`) с обязательным fallback:
  `60m -> 24h -> 7d`; при пустом ряде с `focus_path` выполняется повтор без `focus_path`.
  Это предотвращает регресс «график пропал» и применяется одинаково в `EventsPage` и `SidebarRight`.
- Для `monitoring.anomaly` в drawer добавляем быстрые действия: `Открыть фокус в Мониторинге`, `Показать похожие события`, `Отметить как обработанное`.
- Для старых monitoring-событий без `event_ts/detected_at_utc` используем fallback-маркер по `created_at` события с явной подписью в UI.
- Для `ActivityLogPage` в drawer обязателен блок `Быстрые действия` (контекстные фильтры: по действию/пользователю/IP) как следующий шаг после просмотра записи.
- Для `ActivityLogPage` в drawer добавляем контекстные security-операции по пользователю (`revoke_sessions`, `revoke_trusted_devices`) и локальную пометку `обработано`.
- Блок `Быстрые действия` в drawer реализуется через reusable `ContextQuickActions` и переиспользуется в `EventsPage`/`ActivityLogPage`.
- Для user-контекста в `ActivityLogPage` drawer используем тот же `UserActionPanel`, что и в `UsersPage` (никаких отдельных ad-hoc кнопок действий).
- Для user-контекста в `EventsPage`/`UserDetailsDrawer` используем единый reusable-блок `UserActionPanel` (action + reason + presets + dynamic hint).
- Для `UsersPage` bulk-actions и drawer-контекстов используем один и тот же `UserActionPanel`, чтобы исключить расхождения по UI/UX.
- Для deep-link контекста на целевых страницах обязательно есть явный `Сбросить контекст`, чтобы убрать highlight/focus и вернуться к обычному режиму.
- В layout-компонентах (например, `SidebarLeft`) не привязываем сетевые загрузки к каждому `location.pathname`; используем доменные триггеры роутов + короткий TTL-кэш для данных навигации.

## 9. UI консистентность

- Единые базовые компоненты (кнопки, segmented control, карточки, списки, фильтры).
- При правках текстов/лейблов/подсказок не удаляем релевантные подсказки “для упрощения”.
  Сначала проверяем, где они уже используются, и выносим в общий источник (catalog/helper), чтобы одна и та же подсказка подключалась в нескольких местах.
- Для текстовых подсказок и описаний действий используем централизованный словарь/каталог (по домену), а не локальные строки в каждой странице.
  Если централизованного места еще нет, создаем его как reusable и применяем минимум в 2 местах.
- Все выпадающие списки используем только через reusable `UiSelect`; прямые `<select>` в страницах/feature-компонентах не используем.
- `UiSelect` визуально и по анимациям согласован с `Button`: hover/focus состояния, единая граница/радиус/тональность, кастомная стрелка.
- Поисковые/фильтровые текстовые поля выполняем через reusable `ClearableInput` (кнопка `×` для мгновенной очистки справа).
- Время из API (`created_at`) форматируем через единый helper (`naive UTC -> local`) для консистентности между карточками и системным временем UI.
- Сырые enum-значения backend (`notification/action`, `info/warning/danger` и т.п.) в UI не показываем напрямую:
  используем единый mapping-helper для человекочитаемых русских подписей.
- Одинаковые hover/active/selected состояния.
- Бейджи `AccentPill` имеют единый размер: `font-size: 12px`, `line-height: 1.2`, `padding: 2px 8px`.
- Временные toast-уведомления показываем с плавным `fade/slide` входом и выходом; резкое исчезновение без transition не используем.
- Короткие фиксированные наборы фильтров (`all/notification/action` и аналогичные) оформляем через `SegmentedControl`, а не через `select`.
- Для строк списков: мягкий hover + кликабельность строки там, где это уместно.
- Для email-подсказок в фильтрах журналов/лент не загружаем полный список пользователей на маунте:
  используем lazy-suggest по вводу (`q` + debounce + ограничение top-N).
- Для `UsersPage` и `UserDetailsDrawer` используем единые reusable-блоки:
  `UserStatusPills` (статусы без инфошума), `UserTrustPills`, `SessionSummaryCard`, `DeviceSummaryCard`.
  Краткую строку сессии в списках рендерим через общий `UserListSessionMeta` и используем одинаково в `UsersPage` и `RootAdminsPage`:
  `сессия: <дата> • IP: <ip> • UA: <браузер> (браузер) • <ОС> (ОС) • устройств: <N>`.
  Для консистентной высоты карточек `UserListSessionMeta` рендерится для `approved` пользователей; для `pending` строка не показывается.
  При отсутствии данных у `approved` показываем прочерки (`-`).
  Identity-ряд (`роль + Вы + есть в БД/только ADMIN_EMAILS`) рендерим через reusable `IdentityBadgeRow`.
  Цвета/акценты пользовательских бейджей берём из единой матрицы (`userBadgeCatalog`), а не задаём локально в страницах.
  Цвета бейджей задаются по семантическим группам (а не вперемешку):
  `role/relevance -> холодный identity-спектр с различимыми оттенками по роли`, `status -> зелёный/красный/нейтральный`, `trust -> фиолетовый диапазон`.
  Локальное переопределение цвета бейджа в страницах запрещено, кроме явно оговоренных warning/danger сценариев.
  Для drawer-контекстов группы бейджей рендерим через общий layout `UserBadgeGroups` в порядке:
  `identity -> status -> trust`, чтобы структура и визуальный ритм не расходились между экранами.
  Для trust-контекста в drawer используем детальный reusable-блок `TrustPolicyDetailsCard` (`описание + Код/Срок/Риск`);
  одиночный trust-бейдж в drawer не дублируем.
  Для trust-деталей (`Код/Срок/Риск`) используем общий рендер:
  `Код/Срок/Риск` остаются в trust-палитре (без локального warning-override).
  Для trust/time-бейджей используем разделенный источник:
  trust-палитра (policy-бейдж + `Код/Срок/Риск`) берется из `trust_policy_catalog`,
  time-палитра (`срок доверия` / `статус устройства`) берется из `userBadgeCatalog`.
  Time/device бейджи выведены из compact user-UX; в compact-контексте оставляем только trust-policy бейдж.
  Матрица бейджей хранит не только цвета, но и `label/priority`, чтобы порядок и подписи были едиными на всех экранах.
  `RoleBadge` также берёт стиль и label из `userBadgeCatalog` (без локальной tone-логики), чтобы роли и статусы были в одном цветовом контракте.
  Формат role-лейблов унифицирован: без префикса `роль:`, текст с заглавной буквы (`Наблюдатель`, `Редактор`, `Администратор`, `Root-admin`).
  Approve-бейдж (`доступ подтверждён: да/нет`) не используем: статус подтверждения не дублируем в бейджах.
  `RelevanceBadge` (`Вы` / `Выбранный пользователь`) также берёт стиль и label из `userBadgeCatalog`.
  В `UserDetailsDrawer` показываем все релевантные статусы пользователя: для удалённого пользователя при `is_blocked=true` бейдж `заблокирован` также отображается.
  В user-контекстах (`UsersPage`, `EventsPage`, `ActivityLogPage`) бейдж `Вы` показываем и в списке, и в drawer-контексте для текущего пользователя.
  Технические индикаторы безопасности (например `Версия токена (JWT)`) сопровождаем короткой tooltip-подсказкой о влиянии на сессии.
  Для inline-разделителей внутри кратких строк используем `UI_BULLET = " • "` из `frontend/src/utils/uiText.ts` (не raw-escape в JSX).
  В `UserActionPanel` селект является единственным названием действия: не дублируем заголовок/бейдж действия внутри инфо-карточки.
  В `UserActionPanel` показываем только релевантные действия: soft-delete обозначаем как `Удалить`, hard-delete показываем только в контексте уже удалённых.
  Доверенные устройства в drawer: default `последнее + еще N`, полное раскрытие только по явному действию.
  Для доверенных устройств в drawer поддерживаем контекстные действия (`отозвать устройство`, `отозвать все кроме последнего`) с записью в аудит.
  Блок истории входов в drawer показываем как компактный preview (до 5 уникальных записей), полный список открываем в профильном журнале.
- Для event-карточек в лентах: единая сетка `header / body / footer` и одинаковая высота карточек.
- Event-meta бейджи (`канал / уровень / read / handled`) в drawer-контекстах рендерим через reusable `EventMetaPills`
  (не дублируем локальные наборы `AccentPill` в `EventsPage` и `SidebarRight`).
- В правом `SidebarRight` не размещаем вторичные фильтры (например `security/unhandled`) в заголовке ленты, чтобы не перегружать компактный интерфейс; такие фильтры находятся на полноэкранных страницах.
- Бейджи (`Вы`, `Выбранный`) не должны менять высоту карточки; длинный текст режется через line-clamp/ellipsis.
- Для `Уведомлений` в правом Центре событий допустима адаптивная высота карточки (не фикс), но с ограничением текста (`title/body line-clamp`) и без переполнения.
- Бейдж релевантности (`Вы`) размещается в первой зоне карточки в фиксированном слоте, чтобы заголовок и кнопки не прыгали между карточками.
- Поля `UA` во всех экранах показываем в коротком виде + явная подпись `UA (идентификатор браузера/устройства)`; полный `user-agent` даем в `title`/tooltip.
- KPI-карточки на мониторинге кликабельны и ведут к фильтрации/фокусу таблицы метрик по выбранной метрике.
- Для страницы `Настройки`: группировка по доменам (`Доступ`, `События`, `Наблюдаемость`) и динамический сабтекст/статус на каждом пункте.
- Для `SettingsPage` используем мини-самодиагностику источников: если конкретный API-источник недоступен, на соответствующей карточке показываем явный индикатор ошибки с пояснением.
- Для `SettingsPage` загрузка статистики выполняется параллельно по независимым доменам (`users/root-admins/events/audit/monitoring`) + через короткий TTL-кэш для редко меняющихся счетчиков.
- Для статичных/редко меняющихся справочников UI (`permissions-matrix`, каталоги, списки навигации) используем shared TTL-кэш, а не прямой `apiGet` при каждом маунте компонента.
- Для тяжелых страниц (`Users`, `Activity`, `Monitoring`, `Events`) используем route-level code-splitting (`React.lazy` + `Suspense`) в `App.tsx`, чтобы снижать initial bundle без изменения UX.
- Response-типы backend-каталогов (`actions/trust/audit/available-actions`) централизуем в `frontend/src/types/catalog.ts`.

## 10. Loading / Empty / Error

Для каждого нового блока обязательно:

- loading state,
- empty state,
- error state,
- отсутствие layout-jump при смене состояния.
- Для audit/login-контекста формулировки actor/target должны быть человекочитаемыми (`Вы (email)`, `Кто`, `Кому`), а не только сырой `email -> email`.
- Для IP-полей в аудите и входах всегда указываем контекст источника (`IP инициатора действия` / `IP клиента входа`), а для private range добавляем пометку `внутренняя сеть`.

### 10.1 Формат UI smoke-проверки (обязательно для отчета)

- В итоговом отчете по задаче всегда указываем не только “что проверить”, но и маршрут кликов в UI:
  `Страница -> блок -> действие (клик/ховер/выбор) -> ожидаемый результат`.
- Формат шага проверки:
  `Куда зайти`, `Куда нажать`, `Что должно измениться`, `Что не должно сломаться`.
- Для изменений в drawer/action-подсказках минимум 3 сценария:
  базовый (обычный пользователь),
  self-кейс (`Вы`),
  restricted-кейс (действие недоступно/скрыто по роли или статусу).
- Если менялась только механика реюза (без UX-изменений), в проверке явно пишем:
  “визуально/поведенчески без изменений, проверено по шагам”.
- Каждый итоговый отчет по задаче обязателен в формате:
  `Что было -> Что стало -> Как проверить -> Вклад в цели`.
  Для `Вклад в цели` указываем эффект по целям оптимизации
  (снижение нагрузки/упрощение/реюз) и оценку масштаба (`high/medium/low` или `%`, если измеримо).

## 11. Критичные действия

- Для критичных admin-операций включается подтверждение.
- Подтверждение выполняем только через единый `ConfirmDialog` (кастомный UI), нативные браузерные `confirm/alert/prompt` не используем.
- `reason` обязательно или настоятельно рекомендуется по политике действия.
- reason сохраняется в audit-log.
- Если действие заведомо неприменимо (self / последний админ / нарушает инвариант), control скрывается и заменяется поясняющим статусом, а не просто `disabled`.
- Для полей `reason` в admin-операциях используем пресеты причин (чипы) + ручной ввод.
- В drawer-панелях блоки действий рендерятся компактно по контенту; избегаем пустого вертикального растяжения карточек.
- Кнопки-линки внутри drawer (`Открыть...`) используем компактные (`size=sm`) и выравниваем по контенту (`fit-content`).

## 12. Миграции и совместимость

- Изменения БД только через Alembic миграции.
- Учитываем обратную совместимость и старые записи.

## 13. Кодировка и русский язык (обязательно)

- Все файлы с русским текстом: только `UTF-8`.
- Смешанные кодировки запрещены.
- Любая mojibake исправляется в рамках текущей задачи.
- Если видим кракозябры, обязательная проверка источника на `cp1251` и явная перекодировка в `UTF-8 without BOM`.

## 14. Контракт новой функции

Перед закрытием фичи проверяем:

- RBAC/permissions,
- action catalog (если есть действие),
- audit-log,
- event center,
- monitoring метрики,
- UX состояния (loading/empty/error),
- тесты (unit/integration),
- миграции,
- отсутствие проблем кодировки.

## 15. PR-checklist (минимум)

- Какие роли имеют доступ?
- Какие permissions изменились?
- Добавлен ли action в catalog?
- Пишется ли audit-log?
- Эмитится ли событие в Event Center?
- Добавлены/обновлены ли метрики?
- Проверены ли loading/empty/error?
- Какие паттерны переиспользованы?
- Какие тесты добавлены?
- Есть ли миграции и совместимость?
- Проверена ли UTF-8 кодировка и отсутствие mojibake?

## 16. Итеративный аудит оптимизаций

- Аудит выполняем итерациями: `обнаружение -> фиксация в TODO -> приоритизация -> внедрение -> верификация -> обновление PATTERNS/REUSE`.
- Базовый принцип: `Simplify First`.
  Сначала проверяем, что можно:
  - удалить (dead code / legacy);
  - объединить (дублирующие хелперы/типы/загрузчики);
  - переиспользовать (существующий reusable).
  И только если этого недостаточно, добавляем новую механику/компонент/хук.
- Каждая итерация должна добавлять в `TODO.md` только новые пункты; дубли уже зафиксированных задач запрещены.
- Перед добавлением нового пункта обязательная сверка с:
  - `TODO.md` (нет ли уже такого пункта в `Next`/`Done`);
  - `REUSE_INDEX.md` (нет ли уже закрытого/текущего реюза);
  - `PATTERNS.md` (нет ли уже действующего контракта).
- Формат записи пункта аудита в `TODO.md`:
  - `priority` (`HIGH/MEDIUM/LOW`);
  - `scope` (конкретные страницы/компоненты/утилиты);
  - `problem` (что создает лишнюю нагрузку/сложность);
  - `goal` (какой эффект нужен: меньше запросов/рендеров/файлов/строк);
  - `change idea` (какой реюз/механика/удаление планируется);
  - `simplification` (что именно упрощаем: удаляем/сливаем/централизуем);
  - `risk` (потенциальный регресс);
  - `verification` (как проверяем: typecheck + smoke + метрики/сценарий).
- Для каждого пункта указывать конкретные file refs (путь + при необходимости строка), а не абстрактные описания.
- Статусы вести явно:
  - `Next`: запланировано;
  - `In Progress`: не более одного активного крупного пункта;
  - `Done`: закрыто с кратким итогом эффекта.
- Если в ходе аудита найдено, что пункт не нужен, переносим его в `Неактуально` с краткой причиной.
- Любая оптимизация без изменения UX/бизнес-поведения выполняется по правилу `No-Regression Refactor`; изменение поведения оформляется отдельным согласованием.
- Те же правила применяются к backend-аудиту:
  - `reuse-first` (сначала ищем общий helper/query-builder/cache);
  - не допускаем full-scan + python-фильтрацию там, где можно перенести фильтры/пагинацию в SQL;
  - для тяжелых агрегатов фиксируем TTL-кэш и явные правила инвалидции;
  - каждый backend-пункт фиксируем с file refs и форматом отчета
    `что было -> что стало -> как проверить -> вклад в цели`.

### 16.1 Stop-criteria (порог завершения аудита)

- Чтобы не уходить в бесконечную спираль упрощений, аудит ведем ограниченными волнами.
- Одна волна аудита = до `5` реализованных пунктов (`HIGH/MEDIUM/LOW`) или до `2` крупных структурных рефакторов.
- После каждой волны обязательна мини-ретроспектива в `TODO.md`:
  - что дало измеримый эффект;
  - какие риски/регрессы появились;
  - что осталось с высоким ROI.
- Условие остановки текущей волны и перехода к финалу:
  - в двух подряд проходах не найдено `HIGH` задач;
  - ожидаемый эффект новых пунктов только `LOW` и в сумме < ~10% по целевым метрикам (запросы/рендеры/TTFB/объем кода);
  - стоимость изменений выше ожидаемой пользы (по времени/риску).
- Максимальный порог без отдельного согласования:
  - не более `3` волн подряд для одного домена (frontend-аудит);
  - дальше только по явному подтверждению пользователя.
- Финал аудита обязателен:
  - фиксируем раздел `Audit Final` в `TODO.md` с итогом `что было -> что стало -> как проверено -> что сознательно не трогали`;
  - оставшиеся пункты переводим либо в `Future`, либо в `Неактуально` с причиной.
- Для каждой завершенной итерации (не только финала) применяем тот же формат отчета:
  `что было -> что стало -> как проверить -> вклад в цели`,
  чтобы прогресс по целям был сопоставим между волнами.
